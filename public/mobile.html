<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Javascript Tetris</title>
  <style>
    @import url(https://fonts.googleapis.com/css?family=Open+Sans:400,300);
    body{
      font-family: 'Open Sans', sans-serif;
      font-weight: 300;
      background: #ddd;
      width: 100%;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }

    .keys{
      position: relative;
      width: 450px;
      margin: 0 auto;
      padding:0px;
    }
    .keys > div {
      width: 150px;
      height: 150px;
      text-align: center;
      padding: 50px;
      background: #51CA7D;
      float: left;
      border-radius: 50%;
      
      display: flex;
      display: -webkit-flex;
      display: -ms-flexbox;

      box-sizing: border-box;
      -webkit-flex-wrap: wrap;
      -ms-flex-wrap: wrap;
      flex-wrap: wrap;
      
      align-items: center;
      justify-content: center;
    }
    .keys > .down{
      margin: 0 150px;
    }
    .keys > .space{
      background: #aaa;
      width: 450px;
      border-radius: 0;
      margin-top: 20px;

    }
    .keys.off > div{
      background: #aaa;
    }
    .keys.off > .space{
      margin-top: 20px;
      background: #51CA7D;
      width: 100%;
    }
    .preview { margin-bottom: 20px; margin-top: 20px;}
    #upcoming { display: block; margin: 0 auto; background-color: #E0E0E0; }
    @media screen and (min-width:   0px) and (min-height:   0px)  {  #upcoming { width:  50px; height:  50px; }  } /* 10px chunks */
    @media screen and (min-width: 400px) and (min-height: 400px)  {  #upcoming { width:  75px; height:  75px; }  } /* 15px chunks */
    @media screen and (min-width: 500px) and (min-height: 500px)  {  #upcoming { width: 100px; height: 100px; }  } /* 20px chunks */
    @media screen and (min-width: 600px) and (min-height: 600px)  {  #upcoming { width: 125px; height: 125px; }  } /* 25px chunks */
    @media screen and (min-width: 700px) and (min-height: 700px)  {  #upcoming { width: 150px; height: 150px; }  } /* 30px chunks */
    @media screen and (min-width: 800px) and (min-height: 800px)  {  #upcoming { width: 175px; height: 175px; }  } /* 35px chunks */
    @media screen and (min-width: 900px) and (min-height: 900px)  {  #upcoming { width: 200px; height: 200px; }  } /* 40px chunks */
  </style>

</head>

<body>


  <div class="preview">
    <<<<<<< Updated upstream
    <div class="msg" ></div>
    =======
    <p>Pr√≥xima:</p>
    >>>>>>> Stashed changes
    <canvas id="upcoming"></canvas>
  </div>

  <div class="keys off ">
    <div class="left"   data-code="37">left</div>
    <div class="rotate" data-code="38">rotate</div>
    <div class="right"  data-code="39">right</div>
    <div class="down"   data-code="40">down</div>
    <div class="space"  data-code="32">start</div>
  </div>

  <script src="js/stats.js"></script>
  <script src="https://cdn.socket.io/socket.io-1.2.0.js"></script>
  <script src="http://code.jquery.com/jquery-1.11.1.js"></script>
  <script>
  var socket = io(); 
  var o = false;
  function get(id)        { return document.getElementById(id);  }
 //-------------------------------------------------------------------------
  // game variables (initialized during reset)
  //-------------------------------------------------------------------------

var tetris = {
  /*
  init: function(){
    this.dx, this.dy,        // pixel size of a single tetris block
    this.blocks,        // 2 dimensional array (nx*ny) representing tetris court - either empty block or occupied by a 'piece'
    this.actions,       // queue of user actions (inputs)
    this.playing,       // true|false - game is in progress
    this.dt,            // time since starting this game
    this.current,       // the current piece
    this.next,          // the next piece
    this.score,         // the current score
    this.vscore,        // the currently displayed score (it catches up to score in small chunks - like a spinning slot machine)
    this.rows,          // number of completed rows in the current game
    this.step;          // how long before current piece drops by 1 row   

    this.ucanvas = get('upcoming'),
    this.uctx    = ucanvas.getContext('2d'),
    this.speed   = { start: 0.6, decrement: 0.005, min: 0.1 }, // how long before piece drops by 1 row (seconds)
    this.nx      = 10, // width of tetris court (in blocks)
    this.ny      = 20, // height of tetris court (in blocks)
    this.nu      = 5;  // width/height of upcoming preview (in blocks)
      //console.log(ucanvas, uctx)
    this.invalid = {}; 
  },
  invalidate:       function()  { this.invalid.court  = true; },
  invalidateNext:   function () { this.invalid.next   = true; },
  invalidateScore:  function () { this.invalid.score  = true; },
  invalidateRows:   function () { this.invalid.rows   = true; },

  resize: function(event){
    //canvas.width   = canvas.clientWidth;  // set canvas logical size equal to its physical size
    //canvas.height  = canvas.clientHeight; // (ditto)
    this.ucanvas.width  = this.ucanvas.clientWidth;
    this.ucanvas.height = this.ucanvas.clientHeight;

    this.dx = 200  / this.nx; // pixel size of a single tetris block
    this.dy = 400 / this.ny; // (ditto)

    this.invalidate();
    this.invalidateNext();
  }
*/
};
var pieceObj = {
  /*
    init: function(){

    },
    eachblock: function (type, x, y, dir, fn) {
      var bit, result, row = 0, col = 0, blocks = type.blocks[dir];
      for(bit = 0x8000 ; bit > 0 ; bit = bit >> 1) {
        if (blocks & bit) {
          fn(x + col, y + row);
        }
        if (++col === 4) {
          col = 0;
          ++row;
        }
      }
    },
    dropPiece: function () {
      this.eachblock(current.type, current.x, current.y, current.dir, function(x, y) {
        setBlock(x, y, current.type);
      });
    },
    drawPiece: function (ctx, type, x, y, dir) {
      var loc = this;
      this.eachblock(type, x, y, dir, function(x, y) {
      loc.drawBlock(ctx, x, y, type.color);
      });
    },

    drawBlock: function (ctx, x, y, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x*dx, y*dy, dx, dy);
      ctx.strokeRect(x*dx, y*dy, dx, dy)
    }
    */
}


  var dx, dy,        // pixel size of a single tetris block
      blocks,        // 2 dimensional array (nx*ny) representing tetris court - either empty block or occupied by a 'piece'
      actions,       // queue of user actions (inputs)
      playing,       // true|false - game is in progress
      dt,            // time since starting this game
      current,       // the current piece
      next,          // the next piece
      score,         // the current score
      vscore,        // the currently displayed score (it catches up to score in small chunks - like a spinning slot machine)
      rows,          // number of completed rows in the current game
      step;          // how long before current piece drops by 1 row

  var ucanvas = get('upcoming'),
      uctx    = ucanvas.getContext('2d'),
      speed   = { start: 0.6, decrement: 0.005, min: 0.1 }, // how long before piece drops by 1 row (seconds)
      nx      = 10, // width of tetris court (in blocks)
      ny      = 20, // height of tetris court (in blocks)
      nu      = 5;  // width/height of upcoming preview (in blocks)
      //console.log(ucanvas, uctx)
    var invalid = {};

    function invalidate()         { invalid.court  = true; }
    function invalidateNext()     { invalid.next   = true; }
    function invalidateScore()    { invalid.score  = true; }
    function invalidateRows()     { invalid.rows   = true; }

  function resize(event) {
      //canvas.width   = canvas.clientWidth;  // set canvas logical size equal to its physical size
      //canvas.height  = canvas.clientHeight; // (ditto)
      ucanvas.width  = ucanvas.clientWidth;
      ucanvas.height = ucanvas.clientHeight;


      dx = 200  / nx; // pixel size of a single tetris block
      dy = 400 / ny; // (ditto)

      console.log(dx)
      invalidate();
      invalidateNext();
    }
    resize();
  //------------------------------------------------
  // do the bit manipulation and iterate through each
  // occupied block (x,y) for a given piece
  //------------------------------------------------
  function drawBlock(ctx, x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x*dx, y*dy, dx, dy);
    ctx.strokeRect(x*dx, y*dy, dx, dy);
    
  }
  function eachblock(type, x, y, dir, fn) {
    //console.log(type, x, y, dir)
    var bit, result, row = 0, col = 0, blocks = type.blocks[dir];
    for(bit = 0x8000 ; bit > 0 ; bit = bit >> 1) {
      if (blocks & bit) {
        fn(x + col, y + row);
      }
      if (++col === 4) {
        col = 0;
        ++row;
      }
    }
  }
  function drawPiece(ctx, type, x, y, dir) {

    eachblock(type, x, y, dir, function(x, y) {
      drawBlock(ctx, x, y, type.color);
    });
  }
  function drawNext() {
    
    if (invalid.next) {
      var padding = (nu - next.type.size) / 2; // half-arsed attempt at centering next piece display
      //console.log(padding)
      uctx.save();
      uctx.translate(0.5, 0.5);
      uctx.clearRect(0, 0, nu*dx, nu*dy);
      //console.log(uctx)
      drawPiece(uctx, next.type, padding, padding, next.dir);
      uctx.strokeStyle = 'black';
      uctx.strokeRect(0, 0, nu*dx - 1, nu*dy - 1);
      uctx.restore();
      invalid.next = false;
    }
  }
  invalidate();
  invalidateNext();
  invalidateScore();
  invalidateRows();

  socket.on('render', function(data){
    next = data.next;
    //console.log(next.type);
    invalid.next = true;
    drawNext();

    $('.keys').toggleClass('off',!data.playing);
  });

  socket.on('start turn', function(data){
    $('.msg').html('Seu turno.');
  });

  socket.on('end turn', function(data){
    $('.msg').html('');
  });

  $(function(){
    $('.keys > div').click(function(){
      socket.emit('action', $(this).data('code'));
    });

    socket.emit('add user', 0x000000);

  });  
  </script>

</body>
</html>
